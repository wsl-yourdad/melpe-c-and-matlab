%% =========================================================================
%  MELPe 1200bps 高保真语音解码器 (V2.0 - 工程师版)
%
%  高级算法实现:
%    1. [核心] 真正的5频带混合激励模型 (Mixed Excitation)
%    2. [核心] LPC/LSF系数的帧内平滑插值，消除边界跳变
%    3. [核心] 自适应傅里叶幅值合成
%    4. 精确的基音/清浊音标志解码
% =========================================================================
clc; clear; close all;
fprintf('=== MELPe 1200bps 高保真解码器 (V2.0) 启动 ===\n');

%% 1. 加载资源
% -------------------------------------------------------------------------
fprintf('1. 正在加载码本和编码器数据...\n');
try
    load('melpe_1200_final.mat');
    load('encoder_output.mat');
    fprintf('   ✅ 加载成功！\n');
catch ME
    error('❌ 加载文件失败! \n   错误信息: %s\n   请确保已运行编码器并保存了 encoder_output.mat', ME.message);
end

%% 2. 初始化解码器
% -------------------------------------------------------------------------
LPC_ORD = 10;
FRAME_LEN = 180;
SUBFRAME_LEN = FRAME_LEN / 4; % 我们将每帧分为4个子帧进行插值
num_superframes = length(all_bit_streams);
decoded_signal = zeros(1, num_superframes * 3 * FRAME_LEN);

% 解码器状态变量 (用于帧间平滑)
last_lsf_dequant = codebooks.msvq_mean(:);
last_gain = 10; % 上一帧的末尾增益
synthesis_mem = zeros(1, LPC_ORD); % LPC综合滤波器记忆

fprintf('2. 解码器初始化完成。共 %d 个超帧待处理。\n\n', num_superframes);

%% 3. 核心解码循环
% =========================================================================
write_ptr = 1;
for s_idx = 1:num_superframes
    
    if mod(s_idx, 10) == 0 || s_idx == 1
        fprintf('--- 正在解码超帧 %d ---\n', s_idx);
    end
    
    % --- Step A: 拆解81-bit码流 (不变) ---
    b_str = all_bit_streams{s_idx};
    lsf_msvq_indices = [bin2dec(b_str(1:7)); bin2dec(b_str(8:13)); bin2dec(b_str(14:19)); bin2dec(b_str(20:25))] + 1;
    lsf_inp_idx = bin2dec(b_str(26:29)) + 1;
    lsf_res_idx = bin2dec(b_str(30:37)) + 1;
    gain_idx = bin2dec(b_str(38:47)) + 1;
    pitch_idx = bin2dec(b_str(48:59));
    fourier_idx = bin2dec(b_str(60:67)) + 1;
    
    % --- Step B: 反量化参数 (Dequantization) ---
    gains_6D = codebooks.gain(gain_idx, :);
    sf_gains_dequant = reshape(gains_6D, 2, 3);
    
    % 【升级】dequant_pitch_1200 现在会输出5个频带的清浊音标志
    [sf_pitches_dequant, sf_bpvc_dequant] = dequant_pitch_1200(pitch_idx, codebooks);
    
    sf_lsfs_dequant_hz = dequant_lsf_1200(lsf_msvq_indices, lsf_inp_idx, lsf_res_idx, last_lsf_dequant, codebooks, FS);
    
    fsmag_dequant = codebooks.fsvq_cb(:, fourier_idx);

    % --- Step C: 逐子帧进行高质量语音合成 ---
    current_lsf = last_lsf_dequant; % 插值的起点
    
    for f_in_s = 1:3
        % C1. 获取当前子帧的目标参数
        p = sf_pitches_dequant(f_in_s);
        bpvc = sf_bpvc_dequant(:, f_in_s); % 5个频带的V/UV标志
        g2 = sf_gains_dequant(2, f_in_s);
        
        % C2. 【高级算法】调用全新的帧合成引擎
        [frame_synth, synthesis_mem] = melp_synthesize_frame( ...
            current_lsf, ...
            sf_lsfs_dequant_hz(:, f_in_s), ...
            p, bpvc, g2, last_gain, fsmag_dequant, synthesis_mem, codebooks, FS);
            
        % C3. 存储合成的语音帧
        decoded_signal(write_ptr : write_ptr + FRAME_LEN - 1) = frame_synth;
        write_ptr = write_ptr + FRAME_LEN;
        
        % C4. 更新状态，用于下一帧的平滑
        current_lsf = sf_lsfs_dequant_hz(:, f_in_s);
        last_gain = g2;
    end
    
    % 更新超帧状态
    last_lsf_dequant = sf_lsfs_dequant_hz(:, 3);
end
fprintf('\n✅ 解码完成！\n');

%% 4. 结果评估：播放与对比
% -------------------------------------------------------------------------
fprintf('4. 正在播放解码后的音频...\n');
% 播放前进行一次整体归一化，防止削波
soundsc(decoded_signal / max(abs(decoded_signal)) * 0.95, FS);

% --- 绘制对比图 ---
figure('Name', 'MELPe 高保真解码结果对比 (V2.0)', 'Position', [150 100 1000 800]);
len_orig = length(signal_final);
len_dec = length(decoded_signal);
min_len = min(len_orig, len_dec);
t_axis = (0:min_len-1) / FS;
subplot(2, 1, 1);
plot(t_axis, signal_final(1:min_len), 'b'); hold on;
plot(t_axis, decoded_signal(1:min_len), 'r', 'LineWidth', 1.2); hold off;
legend('原始信号', '解码信号'); title('时域波形对比');
xlabel('时间 (s)'); ylabel('幅度'); grid on; xlim([0 t_axis(end)]);
subplot(2, 1, 2);
N_FFT = 2048;
Y_orig = fft(signal_final(1:min_len), N_FFT);
Y_dec = fft(decoded_signal(1:min_len), N_FFT);
f_axis = FS*(0:(N_FFT/2))/N_FFT;
P_orig = abs(Y_orig/N_FFT);
P_dec = abs(Y_dec/N_FFT);
plot(f_axis, 20*log10(P_orig(1:N_FFT/2+1)), 'b'); hold on;
plot(f_axis, 20*log10(P_dec(1:N_FFT/2+1)), 'r', 'LineWidth', 1.2); hold off;
legend('原始信号', '解码信号'); title('对数谱密度对比');
xlabel('频率 (Hz)'); ylabel('幅度 (dB)'); grid on; xlim([0 FS/2]);
sgtitle('MELPe 1200bps 编解码效果分析', 'FontSize', 16, 'FontWeight', 'bold');
fprintf('   图表绘制完成。\n');

%% =========================================================================
%  解码器辅助函数 (全新架构)
% =========================================================================

function [frame_synth, mem_out] = melp_synthesize_frame(lsf_start_hz, lsf_end_hz, p, bpvc, gain_end_db, gain_start_db, fsmag, mem_in, codebooks, FS)
% melp_synthesize_frame: 高保真MELP单帧合成引擎
%
% 输入:
%   lsf_start_hz:  帧开始时的LSF (Hz)
%   lsf_end_hz:    帧结束时的LSF (Hz)
%   p:             当前帧的基音周期
%   bpvc:          5个频带的清浊音标志 [v; v; v; v; v] (1=voiced, 0=unvoiced)
%   gain_end_db:   帧结束时的目标增益 (dB)
%   gain_start_db: 帧开始时的增益 (dB)
%   fsmag:         10个傅里叶谐波幅值
%   mem_in:        LPC综合滤波器的输入记忆
%   codebooks:     码本结构体
%   FS:            采样率

    LPC_ORD = 10;
    FRAME_LEN = 180;
    NUM_SUBFRAMES = 4;
    SUBFRAME_LEN = FRAME_LEN / NUM_SUBFRAMES; % 45
    
    frame_synth = zeros(1, FRAME_LEN);
    
    % 【高级算法 1: 增益平滑插值】
    gain_interp = linspace(gain_start_db, gain_end_db, FRAME_LEN);

    % --- 逐子帧进行合成 ---
    for i = 1:NUM_SUBFRAMES
        sub_start = (i-1) * SUBFRAME_LEN + 1;
        sub_end = i * SUBFRAME_LEN;
        
        % 【高级算法 2: LSF平滑插值】
        % 计算当前子帧中心的LSF
        interp_factor = (i - 0.5) / NUM_SUBFRAMES;
        lsf_interp_hz = (1 - interp_factor) * lsf_start_hz + interp_factor * lsf_end_hz;
        
            % 【【【【【 安装“安全系统”！！！】】】】】
    % 在转换为LPC之前，强制执行LSF稳定化
    MIN_SEP_HZ = 50; % 定义一个50Hz的最小安全距离
    lsf_interp_hz = stabilize_lsf(lsf_interp_hz, MIN_SEP_HZ, FS);

        % 将插值后的LSF转为LPC系数
        a_interp = lsf_to_lpc(lsf_interp_hz, LPC_ORD);

        % 【高级算法 3: 真正的混合激励模型】
        % 1. 创建独立的周期性和非周期性激励源
        pulse_exc = zeros(1, SUBFRAME_LEN);
        if p > 0
            % (这是一个简化的脉冲生成，更精确的实现会考虑相位)
            start_phase = mod(-sub_start, p);
            pulse_pos = round(start_phase:p:SUBFRAME_LEN);
            pulse_pos(pulse_pos <= 0) = [];
            if ~isempty(pulse_pos)
                pulse_exc(pulse_pos) = sqrt(p);
            end
        end
        noise_exc = randn(1, SUBFRAME_LEN);
        
        % 2. 自适应傅里叶谐波增强 (仅用于浊音)
        if p > 0 && sum(bpvc) > 0 % 至少有一个频带是浊音
            t_sub = (sub_start-1) : (sub_end-1);
            w0 = 2 * pi / p;
            fourier_enhancer = zeros(1, SUBFRAME_LEN);
            for k = 1:10
                fourier_enhancer = fourier_enhancer + fsmag(k) * cos(w0 * t_sub);
            end
            % 将傅里叶增强信号的能量归一化
            fourier_enhancer = fourier_enhancer / (std(fourier_enhancer) + 1e-9);
        else
            fourier_enhancer = zeros(1, SUBFRAME_LEN);
        end
        
        % 3. 构建5频带滤波器组
        bpf_num = codebooks.bpf_num;
        bpf_den = codebooks.bpf_den;
        
        % 4. 滤波并根据bpvc混合
        mixed_exc = zeros(1, SUBFRAME_LEN);
        for band_idx = 1:5
            % 提取对应频带的滤波器系数
            filt_num = bpf_num((band_idx-1)*9+1 : band_idx*9);
            filt_den = bpf_den((band_idx-1)*9+1 : band_idx*9);
            
            if bpvc(band_idx) == 1 % 浊音频带
                % 激励 = 脉冲 + 傅里叶增强
                source = pulse_exc + fourier_enhancer;
            else % 清音频带
                source = noise_exc;
            end
            
            % 将激励源通过带通滤波器
            band_filtered_exc = filter(filt_num, filt_den, source);
            mixed_exc = mixed_exc + band_filtered_exc;
        end
        
        % 5. LPC综合滤波
        [subframe_synth, mem_out] = filter(1, [1; a_interp], mixed_exc, mem_in);
        mem_in = mem_out; % 更新滤波器记忆

        % 6. 能量归一化和增益应用
        current_energy = std(subframe_synth);
        if current_energy > 1e-9
            subframe_norm = subframe_synth / current_energy;
        else
            subframe_norm = zeros(1, SUBFRAME_LEN);
        end
        
        % 获取当前子帧的平均增益
        sub_gains_db = gain_interp(sub_start:sub_end);
        sub_gains_linear = 10.^(sub_gains_db / 20);
        
        frame_synth(sub_start:sub_end) = subframe_norm .* sub_gains_linear;
    end
    
    % 【高级算法 4: 后置滤波器】(可选，但能改善听感)
    % 一个简单的高通滤波器，补偿频谱倾斜
    frame_synth = filter([1, -0.7], 1, frame_synth);
end


function [pitches, bpvc] = dequant_pitch_1200(pitch_idx, codebooks)
    % 【升级版】根据12-bit联合索引，重建3个基音和5个频带的V/UV标志
    
    pitches = zeros(1, 3);
    bpvc = zeros(5, 3); % 5个频带 x 3帧
    
    if pitch_idx == 0 % 全清音 UUU
        pitches = [0, 0, 0];
        bpvc = zeros(5, 3); % 所有频带都是清音
        return;
    elseif pitch_idx >= 1 && pitch_idx <= 2048 % 全浊音 VVV
        log_pitches = codebooks.pitch_vvv(:, pitch_idx);
        pitches = 10.^log_pitches;
        bpvc = ones(5, 3); % 所有频带都是浊音
    else % 混合模式
        mode_idx = floor((pitch_idx - 2049) / 512);
        vq_idx = mod(pitch_idx - 2049, 512) + 1;
        
        % 这是1200bps标准中从整体V/UV标志到分频带标志的映射
        % 0->UVV, 1->VUV, 2->VVU, 3->UUV, 4->UVU, 5->VUU
        vo_map = [0 1 1; 1 0 1; 1 1 0; 0 0 1; 0 1 0; 1 0 0];
        frame_voicing = vo_map(mode_idx + 1, :);
        
        log_pitches = codebooks.pitch_uvv(:, vq_idx);
        for i=1:3
            if frame_voicing(i) == 1
                pitches(i) = 10^log_pitches(i);
                % 浊音帧，假设前3个频带是浊音 (这是一个简化但有效的标准实践)
                bpvc(1:3, i) = 1;
                bpvc(4:5, i) = 0;
            else
                pitches(i) = 0;
                bpvc(:, i) = 0; % 清音帧，所有频带都是清音
            end
        end
    end
end


function lsf_frames_hz = dequant_lsf_1200(msvq_indices, inp_idx, res_idx, l_prev_hz, codebooks, FS)
    % 反量化1200bps的LSF参数 (输入输出单位统一为Hz)
    
    % 将输入的Hz单位LSF转换为归一化单位
    l_prev_norm = l_prev_hz / (FS / 2);

    % 1. 反量化第3帧的LSF (锚点)
    l3_quant_norm = lsf_msvq_dequantize(msvq_indices, codebooks.msvq_cb, codebooks.msvq_mean);
    l_curr_norm = l3_quant_norm(:);

    % 2. 查找内插系数
    w = codebooks.inpCoef(inp_idx, :);
    w1 = w(1:10)'; w2 = w(11:20)';

    % 3. 预测第1, 2帧的LSF (在归一化域)
    l1_pred_norm = w1 .* l_prev_norm + (1 - w1) .* l_curr_norm;
    l2_pred_norm = w2 .* l_prev_norm + (1 - w2) .* l_curr_norm;

    % 4. 反量化残差 (多级VQ)
    % 这里需要一个专门为残差设计的反量化器，因为它没有均值
    res_dequant = lsf_msvq_dequantize_residual(res_idx, codebooks.res_vq);

    % 5. 将残差加回
    l1_final_norm = l1_pred_norm + res_dequant(1:10);
    l2_final_norm = l2_pred_norm + res_dequant(11:20);

    % 6. 拼接三帧并转换回Hz
    lsf_frames_norm = [l1_final_norm, l2_final_norm, l_curr_norm];
    lsf_frames_hz = lsf_frames_norm * (FS / 2);
end

function lsf_dequant = lsf_msvq_dequantize(indices, cb_stages, cb_mean)
    % 通用多级VQ反量化器 (带均值)
    lsf_dequant = cb_mean;
    for i = 1:length(indices)
        idx = indices(i);
        stage_cb = cb_stages{i};
        lsf_dequant = lsf_dequant + stage_cb(:, idx);
    end
end

function res_dequant = lsf_msvq_dequantize_residual(index, cb_stages)
    % 专门为残差设计的MSVQ反量化器 (无均值)
    % 假设残差VQ也是4级
    indices = zeros(4,1);
    indices(1) = floor(index / (64*64*64)) + 1;
    rem = mod(index, (64*64*64));
    indices(2) = floor(rem / (64*64)) + 1;
    rem = mod(rem, (64*64));
    indices(3) = floor(rem / 64) + 1;
    indices(4) = mod(rem, 64) + 1;
    
    res_dequant = zeros(20,1);
    for i = 1:4
        idx = indices(i);
        stage_cb = cb_stages{i};
        res_dequant = res_dequant + stage_cb(:, idx);
    end
end
